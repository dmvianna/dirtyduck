#+TITLE: Dirty duck: A triage's guided tour
#+AUTHOR: Center of Data Science for Public Policy
#+EMAIL: adolfo@uchicago.edu
#+STARTUP: showeverything
#+STARTUP: nohideblocks
#+STARTUP: indent
#+PROPERTY: header-args:sql :engine postgresql
#+PROPERTY: header-args:sql+ :dbhost 0.0.0.0
#+PROPERTY: header-args:sql+ :dbport 5434
#+PROPERTY: header-args:sql+ :dbuser food_user
#+PROPERTY: header-args:sql+ :dbpassword some_password
#+PROPERTY: header-args:sql+ :database food
#+PROPERTY: header-args:sql+ :results table drawer
#+PROPERTY: header-args:shell     :results drawer
#+PROPERTY: header-args:ipython   :session food_inspections
#+PROPERTY: header-args:python    :results output drawer

* Triage

Predictive analytics projects require the coordination of many
different tasks, such as feature generation, classifier training,
evaluation, and list generation. These tasks are complicated in their
own right, but in addition have to be combined in different ways
throughout the course of the project.

=Triage= aims to provide interfaces to these different phases of a
project, such as an Experiment. Each phase is defined by configuration
specific to the needs of the project, and an arrangement of core data
science components that work together to produce the output of that
phase.

=Triage= was created to facilitate the creation of supervised learning
models, in particular classification models with an strong temporal
component in the data.

The temporal component in the data set affects the modeling mainly in
two ways, first, you need to be very careful and avoid /leakage/ of
information in the data, and second, in the possible temporal drifting of the
data. =Triage= solves the first splitting the data in temporal blocks to be
used in the temporal crossvalidation and using those blocks for the
feature generation.

=Triage= uses the concept of /experiment/. An /experiment/ consists in a
series of steps which aim to generate a good model for predicting the
/label/ of an new instance of the data set. The steps are /feature generation/,
/label generation/, /model training/ and /model scoring/. In each of all
this steps, =triage= will take care of the temporal nuances of the data.

=Triage= will train one model for each block generated, so when the
experiment finishes you will have several models for each algorithm
and selection of hyperparameters. =Triage= calls this a =model_group=.


** Triage interface

=Triage= is very simple to use, but it contains a lot of complex
concepts that we will try to clarify in this section of the tutorial.

For running a =triage= experiment you need the following:

- =triage= installed in your environment (this is already install in the
  docker container). You can verify that =triage= is installed typying
  the following inside an =ipython= session:

#+BEGIN_SRC python
import triage
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

- A database connection

#+BEGIN_SRC python
import os
import sqlalchemy

food_db ="postgresql://food_user:some_password@0.0.0.0:5434/food"
# os.environ.get('FOOD_DB_URL')

print(food_db)
#+END_SRC

#+RESULTS:
:RESULTS:
None
:END:

- An experiment config file, we will discuss this file at length in this
  section of the tutorial.

#+BEGIN_SRC python
with open('inspections_test.yaml') as f:
    experiment_config = yaml.load(f)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:


With this three components you can create your =experiment= object and
=run= it.

*** Configuration file

The experiment configuration file is used to create the experiment
object. Here, you will specify the temporal configuration, the
features to be generated, the labels to learn and the models that you
want to train in your data.

The configuration file is a =yaml= file with the following main sections:


- [[Temporal crossvalidation][temporal_config]] :: Temporal specification of the data, used for
     creating the blocks for temporal crossvalidation.

- =events_table= :: Table that contains the information about the labels
                    to be predicted

- [[Feature engineering][feature_generation]] :: Which spatio-temporal aggregations of the
     columns in the data set do you want to generate as features for
     the models?

- =state_config=  :: Specify which objects are in a given state in a
     particular interval of time, you can use this for filter which
     objects should be included in the training and prediction.

- =model_group_keys= :: How do you want to identify the =model_group= in
     the data

- =grid_config= :: Which combination of hyperparameters and algorithms
                   will be trained and evaluated in the data set?

- =scoring= :: Which metrics will be calculated?

*** The =Experiment= object

Everything revolves around the =experiment= object. You can instantiate
an =experiment= as follows:


#+BEGIN_SRC python
from triage.component.catwalk.storage import FSModelStorageEngine
from triage.experiments import SingleThreadedExperiment

experiment = SingleThreadedExperiment(
    config=experiment_config,
    db_engine=sqlalchemy.create_engine(food_db),
    model_storage_class=FSModelStorageEngine,
    project_path='triage'
)
#+END_SRC

The =experiment= object supports some basic validation:

#+BEGIN_SRC python
experiment.validate()
#+END_SRC

If you are ready for run it, you could start your experiment with:

#+BEGIN_SRC python
experiment.run()
#+END_SRC


** Temporal crossvalidation

The most acute problems are avoiding leakage and feature generation in
a temporal setting.

=Triage= uses the handy =timechop= library for this purpose. =Timechop=
will build ("chop") the data set in several temporal blocks. These
blocks will be used for creating the features and matrices for
the training and evaluation of the machine learning models.

Timechop requires the following parameters:

- =feature_start_time= :: data aggregated into features begins at this point
# earliest date included in features
- =feature_end_time= :: data aggregated into features is from before this
  point
# latest date included in features
- =label_start_time= :: data aggregated into labels begins at this point
# earliest event date included in any label (event date >= label_start_time)
- =label_end_time= :: data aggregated is from before this point
# event date < label_end_time to be included in any label
- =model_update_frequency= :: amount of time between train/test splits
# how frequently to retrain models (days, months, years)
- =training_as_of_date_frequencies= :: how much time between rows for a
  single entity in a training matrix
# list :: time between rows for same entity in train matrix
- =max_training_histories= :: the maximum amount of history for each
  entity to train on (early matrices may contain less than this time
  if it goes past label/feature start times)
# max length of time for labels included in a train matrix :: default = max (label_start_time to now)
- =training_label_timespans= :: how much time is covered by training
  labels (e.g., outcomes in the next 1 year? 3 days? 2 months?)
  (training prediction span)
# time period across which outcomes are determined in train matrices
- =test_as_of_date_frequencies= :: how much time between rows for a
  single entity in a test matrix
# time between rows for same entity in test matrix  :: inspections -  planning/scheduling frequency, eis = reviewing frequency (default = 1week)
- =test_durations= :: how far into the future should a model be used to
  make predictions (in the typical case of wanting a single prediction
  set immediately after model training, this should be set to 0 days)
(test span)
# length of time included in a test matrix (default = training_prediction_span) inspections = how far out are you scheduling for? eis = model_update_frequency
- =test_label_timespans= :: how much time is covered by test predictions
  (e.g., outcomes in the next 1 year? 3 days? 2 months?)
(test prediction span)
# time period across which outcomes are labeled in test matrices (default for eis = training_prediction_span, inspections = test_data_span)


#+BEGIN_SRC python
experiment.config['temporal_config']
#+END_SRC

#+RESULTS:
:RESULTS:
]0;IPython: dsapp/triage-tutorial>>> [0;31m---------------------------------------------------------------------------[0m
[0;31mNameError[0m                                 Traceback (most recent call last)
[0;32m<ipython-input-1-a27e87d7ee14>[0m in [0;36m<module>[0;34m()[0m
[0;32m----> 1[0;31m [0mexperiment[0m[0;34m.[0m[0mconfig[0m[0;34m[[0m[0;34m'temporal_config'[0m[0;34m][0m[0;34m[0m[0m
[0m
[0;31mNameError[0m: name 'experiment' is not defined
> [0;32m<ipython-input-1-a27e87d7ee14>[0m(1)[0;36m<module>[0;34m()[0m
[0;32m----> 1 [0;31m[0mexperiment[0m[0;34m.[0m[0mconfig[0m[0;34m[[0m[0;34m'temporal_config'[0m[0;34m][0m[0;34m[0m[0m
[0m
ipdb>
>>>
:END:


#+BEGIN_EXAMPLE
    model_update_frequency='1year',
    training_label_timespans='3month',
    training_as_of_date_frequencies='3month',
    max_training_histories='2year',

    test_durations='3month',
    test_label_timespans='3month',
    test_as_of_date_frequencies='1month'
#+END_EXAMPLE

With that configuration our time splits looks like:

#+BEGIN_SRC python :results file
import utils

utils.show_timechop(utils.chopper, file_name="timechop_example.png")

return "timechop_example.png"
#+END_SRC

#+RESULTS:
[[file:timechop_example.png]]


** Feature engineering

We will show how to create features, we will use the same subset (one
facility) and only one variable, and some spatial and temporal
dimensions.

For this, we will create a new =schema=

#+BEGIN_SRC sql
create schema if not exists triage
#+END_SRC

#+RESULTS:

We need a table that represents if the facility is "active" in the
moment of the inspection (we don't want to predict a facility that is
not active). We don't want to complicate the calculation here, so, we
will assume that all the facilities are active in *every inspection*


#+BEGIN_SRC sql
drop table if exists triage.all_facilities cascade;

create table triage.all_facilities as (
    select license_num, facility_type, location, date
    from (select distinct license_num, facility_type, location from semantic.events where license_num = 1974745) a
    cross join (select distinct date as date from semantic.events) b
-- select
-- distinct license_num,
-- 'active'::text as state,
-- min(date) as start,
-- max(date) as end
-- from semantic.events
-- group by license_num
) ;


create index on triage.all_facilities(license_num, date);
#+END_SRC

#+RESULTS:


#+BEGIN_SRC sql
select * from triage.all_facilities limit 5;
#+END_SRC

#+RESULTS:
:RESULTS:
| license_num | facility_type | location                                           |       date |
|------------+--------------+----------------------------------------------------+------------|
|    1974745 | liquor       | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | 2016-11-10 |
|    1974745 | restaurant   | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | 2016-11-10 |
|    1974745 | liquor       | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | 2015-05-05 |
|    1974745 | restaurant   | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | 2015-05-05 |
|    1974745 | liquor       | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | 2013-05-06 |
:END:

#+BEGIN_SRC sql
select count(*) from triage.all_facilities
#+END_SRC

#+RESULTS:
:RESULTS:
|    count |
|----------|
| 57683187 |
:END:


Almost all the components of =triage= works with =SQL= tables stored  in
=PostgreSQL= (this is very important to remember), so, let's create our
test table with the =license_num= =1974745=:

#+BEGIN_SRC  sql
drop table if exists triage.test;

create table triage.test as (
select
inspection, -- event
license_num,  -- entity
facility_type,
type as inspection_type, risk, -- variables
violations, -- json array of variables
date, location, zip_code -- spatio temporal dimensions
from semantic.events
where license_num = 1974745
)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC sql
select license_num, inspection_type, risk, date, zip_code from triage.test order by date desc  limit 5
#+END_SRC

#+RESULTS:
:RESULTS:
| license_num | inspection_type | risk |       date | zip_code |
|------------+----------------+------+------------+---------|
|    1974745 | canvass        | high | 2016-10-17 |   60612 |
|    1974745 | canvass        | high | 2015-10-20 |   60612 |
|    1974745 | complaint      | high | 2015-01-12 |   60612 |
|    1974745 | canvass        | high | 2014-10-08 |   60612 |
|    1974745 | canvass        | high | 2014-10-06 |   60612 |
:END:

=triage.test= contains two categorical variables (=inspection_type,risk=),
two differnent groups for aggregation (=location, zip_code=), and the date
when the inspection happened (=date=).

=Collate= is the python library that we will use (and =triage= also) for
controlling the generation of features (including the imputation rules
for each feature generated). =Collate= helps the modeler to
create features based on /spatio-temporal aggregations/ (which is what
we need in our modeling strategy based on *events*)

As a first feature we want to know in a given interval of time, given
one specific date, how many inspections and the flag resulted in "high risk"
after the previous inspection (the =risk= column), happened to the
facility and in the zip code in which the facility operates.

Let's try to construct that in =SQL=:

#+BEGIN_SRC sql
select license_num, zip_code,
count(*) as inspections,
count(*) filter (where risk='high') as flagged_as_high_risk
from triage.test
group by grouping sets(license_num, zip_code)
#+END_SRC

#+RESULTS:
:RESULTS:
| license_num | zip_code | inspections | flagged_as_high_risk |
|------------+---------+-------------+-------------------|
| 1974745    | [NULL]  |          57 |                14 |
| [NULL]     | 60612   |          57 |                14 |
:END:

What about if we want to add the proportion of all the inspections
that resulted in be flagged as "high risk"?

#+BEGIN_SRC sql
select license_num, zip_code,
count(*) as inspections,
count(*) filter (where risk='high') as flagged_as_high_risk,
avg((risk='high')::int) as proportion_of_flags_as_high_risk
from triage.test
group by grouping sets(license_num, zip_code)
#+END_SRC

#+RESULTS:
:RESULTS:
| license_num | zip_code | inspections | flagged_as_high_risk | proportion_of_flags_as_high_risk |
|------------+---------+-------------+-------------------+-----------------------------|
| 1974745    | [NULL]  |          57 |                14 |      0.24561403508771929825 |
| [NULL]     | 60612   |          57 |                14 |      0.24561403508771929825 |
:END:

But, what if we want to add also "medium" and "low" risk? And note
that we didn't add the temporal interval neither. You can see that the
event this simple set of features will require a very complex =SQL= to
be constructed. For this problem, =collate= has the =Categorical= object.

First note that the previous =SQL= query is composed by three parts:
- The filter ((=risk = 'high')::int=)
- The aggregation function (=avg()=)
- The name of the resulting transformation (=proportion_of_flags_as_high_risk=)

In collate, this aggregated column would be defined as:


#+BEGIN_SRC python
from  triage.component.collate import Categorical

risks = Categorical("risk", # the column
                    ["high", "medium", "low"], # compare to, i.e. 'risk = high', 'risk=low', etc
                    "avg", # aggregation function
                    {'coltype':'categorical', 'all': {'type': 'zero'}} # imputation rules
)
#+END_SRC



Note also that we specify the imputation strategy for how to handle
the null values in the resulting fields, in this example we use the
=mean= value.

We are not still ready for use this aggregated variable as a feature,
we need to take in account the spatio and temporal context.


#+BEGIN_SRC python

import sqlalchemy
from triage.component.collate import  SpacetimeAggregation

# We need a connection to the data base
db_url = f"postgresql://food_user:some_password@0.0.0.0:5434/food"
engine = sqlalchemy.create_engine(db_url, client_encoding='utf8')

db_connection = engine.connect()

st = SpacetimeAggregation([risks], # The Categorical object
                          from_obj='triage.test', # FROM
                          groups=['license_num','zip_code'],  # GROUP BY
                          dates=["2014-10-06",
                                 "2014-10-08",
                                 "2015-01-12",
                                 "2015-10-20",
                                 "2016-10-17"], # AS OF DATES, This comes from Timechop, are used as 'WHERE date = ...'
                          intervals={"license_num": ["1 year"], "zip_code": ["1 year"]}, # This will be used as the intervals in the past of the AS OF DATE
                          date_column="date", # Which is the name of the date column?
                          state_table='triage.all_facilities', # State table name
                          state_group='license_num', # Which is the column that identifies the entity
                          output_date_column='date',
                          schema='triage', # In which schema do you want to store the results?
                          prefix='test_risks'
)
#+END_SRC

The =SpacetimeAggregation= object is in charge of create the
agregations, another way of see it, is that it encapsulates the FROM section of the
query (=from_obj=) as well as the
GROUP BY columns (=groups=).

In the example above it will create features based on individual
restaurants (using =license_num=) but also /contextual/ features related
to information about the zip code (=zip_code=) in which the facility is
operating.

The state table (=state_table=) specified here should contain the
comprehensive set of facilities and dates for which output should be
generated for them, regardless if they exist in the =from_obj=.

The attribute =intervals= specifies the date range partitioning for the
feature: it will create the aggregation over the past =1 year= for the
grouping given by the =license_num= nad for the =zip_code=, and
additionally  will give an extra grouping statistic of two months for
the =zip_code=.

Before execute the queries, you could actually look them using the following

#+BEGIN_SRC python
import utils

utils.show_features_queries(st)
#+END_SRC

This will execute queries as the following for the group tables (like =test_risks_zip_code=):

#+BEGIN_EXAMPLE sql

...

SELECT zip_code, '2016-10-17'::date AS date,
avg((risk = 'high')::INT) FILTER (WHERE date >= '2016-10-17'::date - interval '1 year') AS "test_risks_zip_code_1 year_risk_high_avg",
avg((risk = 'medium')::INT) FILTER (WHERE date >= '2016-10-17'::date - interval '1 year') AS "test_risks_zip_code_1 year_risk_medium_avg",
avg((risk = 'low')::INT) FILTER (WHERE date >= '2016-10-17'::date - interval '1 year') AS "test_risks_zip_code_1 year_risk_low_avg",
avg((risk = 'high')::INT) FILTER (WHERE date >= '2016-10-17'::date - interval '2 year') AS "test_risks_zip_code_2 year_risk_high_avg",
avg((risk = 'medium')::INT) FILTER (WHERE date >= '2016-10-17'::date - interval '2 year') AS "test_risks_zip_code_2 year_risk_medium_avg",
avg((risk = 'low')::INT) FILTER (WHERE date >= '2016-10-17'::date - interval '2 year') AS "test_risks_zip_code_2 year_risk_low_avg"
FROM triage.test
WHERE date < '2016-10-17'AND date >= '2016-10-17'::date - greatest(interval '1 year',interval '2 year') GROUP BY zip_code

...

#+END_EXAMPLE


and the next query for the =test_risks_aggregation= table:

#+BEGIN_EXAMPLE sql
CREATE TABLE "triage"."both_aggregation" AS (SELECT * FROM (SELECT license_num, zip_code, '2014-10-06'::date AS date
FROM triage.test
WHERE date < '2014-10-06'AND date >= '2014-10-06'::date - greatest(interval '1y') GROUP BY license_num, zip_code
UNION ALL
SELECT license_num, zip_code, '2014-10-08'::date AS date
FROM triage.test
WHERE date < '2014-10-08'AND date >= '2014-10-08'::date - greatest(interval '1y') GROUP BY license_num, zip_code
UNION ALL
SELECT license_num, zip_code, '2015-01-12'::date AS date
FROM triage.test
WHERE date < '2015-01-12'AND date >= '2015-01-12'::date - greatest(interval '1y') GROUP BY license_num, zip_code
UNION ALL
SELECT license_num, zip_code, '2015-10-20'::date AS date
FROM triage.test
WHERE date < '2015-10-20'AND date >= '2015-10-20'::date - greatest(interval '1y') GROUP BY license_num, zip_code
UNION ALL
SELECT license_num, zip_code, '2016-10-17'::date AS date
FROM triage.test
WHERE date < '2016-10-17'AND date >= '2016-10-17'::date - greatest(interval '1y') GROUP BY license_num, zip_code) t1
LEFT JOIN "triage"."both_license_num" USING (license_num, date)
LEFT JOIN "triage"."both_zip_code" USING (zip_code, date));
#+END_EXAMPLE

You can create the features tables executing the following:

#+BEGIN_SRC python
st.execute(db_connection) # with a SQLAlchemy engine object
#+END_SRC


#+RESULTS:
:RESULTS:
:END:

This will create 3 tables (One for the =license_num=, one for =zip_code=
and one for the combination: =license_num + zip_code=) and one extra
table for the imputated values.

The names of the generated tables are constructed as follows:

#+BEGIN_EXAMPLE
schema.prefix_{group, aggregation}
#+END_EXAMPLE

Inside each of those new tables, the column name will follow this
pattern:

#+BEGIN_EXAMPLE
prefix_group_interval_categorical_operation
#+END_EXAMPLE

For example the tables inside the triage schema are:

#+BEGIN_SRC sql
\dt triage.test_risks*
#+END_SRC

#+RESULTS:
:RESULTS:
| List of relations |                             |       |          |
|-------------------+-----------------------------+-------+----------|
| Schema            | Name                        | Type  | Owner    |
| triage            | test_risks_aggregation        | table | food_user |
| triage            | test_risks_aggregation_imputed | table | food_user |
| triage            | test_risks_license_num         | table | food_user |
| triage            | test_risks_zip_code            | table | food_user |
:END:

And inside =test_risk_aggregation= the columns are:

#+BEGIN_SRC sql
\d triage.test_risks_aggregation
#+END_SRC

#+RESULTS:
:RESULTS:
| Table "triage.test_risks_aggregation"                 |                   |           |
|-----------------------------------------------------+-------------------+-----------|
| Column                                              | Type              | Modifiers |
| zip_code                                             | character varying |           |
| date                                                | date              |           |
| license_num                                          | numeric           |           |
| test_risks_license_num_1 year_inspection_type_canvass_sum   | bigint            |           |
| test_risks_license_num_1 year_inspection_type_complaint_sum | bigint            |           |
| test_risks_zip_code_1 year_inspection_type_canvass_sum      | bigint            |           |
| test_risks_zip_code_1 year_inspection_type_complaint_sum    | bigint            |           |
:END:


The =triage.test_risks_zip_code= table
have two feature columns for every zip code in our table =triage.test=,
looking at the total and average number of complaints in that
=zip_code= over the year prior and 2 months prior to the date in the =date= column.


#+BEGIN_SRC sql
select * from triage.test_risks_zip_code  order by date limit 5;
#+END_SRC

#+RESULTS:
:RESULTS:
| zip_code |       date | test_risks_zip_code_1 year_risk_high_avg | test_risks_zip_code_1 year_risk_medium_avg | test_risks_zip_code_1 year_risk_low_avg | test_risks_zip_code_2 year_risk_high_avg | test_risks_zip_code_2 year_risk_medium_avg | test_risks_zip_code_2 year_risk_low_avg |
|---------+------------+-----------------------------------+-------------------------------------+----------------------------------+-----------------------------------+-------------------------------------+----------------------------------|
|   60612 | 2014-10-06 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2014-10-08 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2015-01-12 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2015-10-20 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2016-10-17 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
:END:

The table =triage.test_risks_license_num= contains two feature columns for each
license that describe the total number of complaints
the past one year.

#+BEGIN_SRC sql
select * from triage.test_risks_license_num  order by date limit 5;
#+END_SRC

#+RESULTS:
:RESULTS:
| license_num |       date | test_risks_license_num_1 year_risk_high_avg | test_risks_license_num_1 year_risk_medium_avg | test_risks_license_num_1 year_risk_low_avg |
|------------+------------+--------------------------------------+----------------------------------------+-------------------------------------|
|    1974745 | 2014-10-06 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |
|    1974745 | 2014-10-08 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |
|    1974745 | 2015-01-12 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |
|    1974745 | 2015-10-20 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |
|    1974745 | 2016-10-17 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |
:END:

The =triage.test_aggregation= table joins these results together to make
it easier to look at both zip_code and facility-level effects
for any given facility.

#+BEGIN_SRC sql
select * from triage.test_risks_aggregation order by date limit 5;
#+END_SRC

#+RESULTS:
:RESULTS:
| zip_code |       date | license_num | test_risks_license_num_1 year_risk_high_avg | test_risks_license_num_1 year_risk_medium_avg | test_risks_license_num_1 year_risk_low_avg | test_risks_zip_code_1 year_risk_high_avg | test_risks_zip_code_1 year_risk_medium_avg | test_risks_zip_code_1 year_risk_low_avg | test_risks_zip_code_2 year_risk_high_avg | test_risks_zip_code_2 year_risk_medium_avg | test_risks_zip_code_2 year_risk_low_avg |
|---------+------------+------------+--------------------------------------+----------------------------------------+-------------------------------------+-----------------------------------+-------------------------------------+----------------------------------+-----------------------------------+-------------------------------------+----------------------------------|
|   60612 | 2014-10-06 |    1974745 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2014-10-08 |    1974745 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2015-01-12 |    1974745 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2015-10-20 |    1974745 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
|   60612 | 2016-10-17 |    1974745 |               1.00000000000000000000 |                 0.00000000000000000000 |              0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |            1.00000000000000000000 |              0.00000000000000000000 |           0.00000000000000000000 |
:END:


Finally, the =triage.test_risks_aggregated_imputed= table fills in null values using the
imputation rules specified in the =Categorical= constructor.

#+BEGIN_SRC python

inspection_types = Categorical("inspection_type", # the column
                    ["canvass", "complaint"], # compare to, i.e. 'inspection_type = canvass', etc.
                    "sum", # aggregation function
                    {'coltype':'categorical', 'all': {'type': 'zero'}} # imputation rules
)

st = SpacetimeAggregation([inspection_types], # The Categorical object
                          from_obj='triage.test', # FROM
                          groups=['license_num','zip_code'],  # GROUP BY
                          dates=["2014-10-06",
                                 "2014-10-08",
                                 "2015-01-12",
                                 "2015-10-20",
                                 "2016-10-17"], # AS OF DATES, This comes from Timechop, are used as 'WHERE date = ...'
                          intervals={"license_num": ["1y"], "zip_code": ["1y"]}, # This will be used as the intervals in the past of the AS OF DATE
                          date_column="date", # Which is the name of the date column?
                          state_table='triage.all_facilities', # State table name
                          state_group='license_num', # Which is the column that identifies the entity
                          output_date_column='date',
                          schema='triage', # In which schema do you want to store the results?
                          prefix='inspection_type'
)

st.execute(db_connection)
#+END_SRC

This will create, as you probably guessed, four new tables:
=inspection_type_{license_num, zip_code, aggregation, aggregation_imputed}=


Or you can mix the two in one step:

#+BEGIN_SRC python
st = SpacetimeAggregation([risks,inspection_types], # The Categorical object
                          from_obj='triage.test', # FROM
                          groups=['license_num','zip_code'],  # GROUP BY
                          dates=["2014-10-06",
                                 "2014-10-08",
                                 "2015-01-12",
                                 "2015-10-20",
                                 "2016-10-17"], # AS OF DATES, This comes from Timechop, are used as 'WHERE date = ...'
                          intervals={"license_num": ["1y"], "zip_code": ["1y"]}, # This will be used as the intervals in the past of the AS OF DATE
                          date_column="date", # Which is the name of the date column?
                          state_table='triage.all_facilities', # State table name
                          state_group='license_num', # Which is the column that identifies the entity
                          output_date_column='date',
                          schema='triage', # In which schema do you want to store the results?
                          prefix='both'
)

#+END_SRC


Checking the columns inside =triage.both_aggregation= , you will note
that all the previous columns are there (except for the prefix):

#+BEGIN_SRC sql
\d triage.both_aggregation
#+END_SRC

#+RESULTS:
:RESULTS:
| Table "triage.both_aggregation"             |                   |           |
|--------------------------------------------+-------------------+-----------|
| Column                                     | Type              | Modifiers |
| zip_code                                    | character varying |           |
| date                                       | date              |           |
| license_num                                 | numeric           |           |
| both_license_num_1y_risk_high_avg                | numeric           |           |
| both_license_num_1y_risk_medium_avg              | numeric           |           |
| both_license_num_1y_risk_low_avg                 | numeric           |           |
| both_license_num_1y_inspection_type_canvass_sum   | bigint            |           |
| both_license_num_1y_inspection_type_complaint_sum | bigint            |           |
| both_zip_code_1y_risk_high_avg                   | numeric           |           |
| both_zip_code_1y_risk_medium_avg                 | numeric           |           |
| both_zip_code_1y_risk_low_avg                    | numeric           |           |
| both_zip_code_1y_inspection_type_canvass_sum      | bigint            |           |
| both_zip_code_1y_inspection_type_complaint_sum    | bigint            |           |
:END:


Obviously you could want to create more complicated variables, for
example, we have a =json= column in our =semantic.events= table, as well
as a geographical column: =location=. Let's do create some features
using those.


*** Add number of violations by severity

Our =semantic.events= has a =json= column called =violations=. We will like
to have an idea of how many types of violations were inspected or at
least their severity. One way of do that is shown in the next =SQL= code:


#+BEGIN_SRC sql
select inspection, license_num, zip_code, array_agg(obj ->> 'severity'),
count(*) filter (where obj ->> 'severity' = 'critical') as critical_violations,
count(*) filter (where obj ->> 'severity' = 'serious') as serious_violations,
count(*) filter (where obj ->> 'severity' = 'minor') as low_violations
from
(select inspection, license_num, zip_code, jsonb_array_elements(violations::jsonb) as obj from semantic.events)
as t1
group by inspection, license_num, zip_code
limit 5
#+END_SRC

#+RESULTS:
:RESULTS:
| inspection | license_num | zip_code | array_agg                                       | critical_violations | serious_violations | low_violations |
|------------+------------+---------+------------------------------------------------+--------------------+-------------------+---------------|
|     100209 |    1226806 |   60622 | {critical,minor,minor,minor,minor,minor,minor} |                  1 |                 0 |             6 |
|     100210 |    1675467 |   60604 | {NULL}                                         |                  0 |                 0 |             0 |
|     100211 |    2017593 |   60612 | {critical,serious}                             |                  1 |                 1 |             0 |
|     100212 |    2017593 |   60612 | {critical,serious}                             |                  1 |                 1 |             0 |
|     100213 |    2017164 |   60612 | {critical,serious}                             |                  1 |                 1 |             0 |
:END:

Basically, this code gives us the number of violations inspected by
severity. How about to get the total and proportion of violations in a
facility in the previous year and the average and standard deviation
for the zip code zone?  Note than in this case the variable is not
*categorical*, is a numeric one, fortunately =collate= also provides
support for numerical variables: the =Aggregate= object

#+BEGIN_SRC python
violations_sql = """
(
select inspection, license_num, zip_code, date,
count(*) filter (where obj ->> 'severity' = 'critical') as critical_violations,
count(*) filter (where obj ->> 'severity' = 'serious') as serious_violations,
count(*) filter (where obj ->> 'severity' = 'minor') as low_violations
from
(select inspection, license_num, zip_code, date, jsonb_array_elements(violations::jsonb) as obj from triage.test)
as t1
group by inspection, license_num, zip_code, date
) as t
"""

critical_violations = Aggregate({'critical': 'critical_violations'}, ['sum', 'avg', 'stddev'], {'coltype':'aggregate', 'all': {'type': 'mean'}})
serious_violations = Aggregate({'serious': 'serious_violations'}, ['sum', 'avg', 'stddev'], {'coltype':'aggregate', 'all': {'type': 'mean'}})
low_violations = Aggregate({'low': 'low_violations'}, ['sum', 'avg', 'stddev'], {'coltype':'aggregate', 'all': {'type': 'mean'}})

st = SpacetimeAggregation([critical_violations, serious_violations, low_violations], # The Categorical object
                          from_obj=violations_sql, # FROM
                          groups=['license_num','zip_code', 'inspection'],  # GROUP BY
                          dates=["2014-10-06",
                                 "2014-10-08",
                                 "2015-01-12",
                                 "2015-10-20",
                                 "2016-10-17"], # AS OF DATES, This comes from Timechop, are used as 'WHERE date = ...'
                          intervals={"license_num": ["1y"], "zip_code": ["1y"], "inspection": ["0d"]}, # This will be used as the intervals in the past of the AS OF DATE
                          date_column="date", # Which is the name of the date column?
                          state_table='triage.all_facilities', # State table name
                          state_group='license_num', # Which is the column that identifies the entity
                          output_date_column='date',
                          schema='triage', # In which schema do you want to store the results?
                          prefix='violations'
)

st.execute(db_connection)

#+END_SRC


#+BEGIN_EXAMPLE sql
...
SELECT license_num, '2014-10-08'::date AS date,
sum(critical_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_critical_sum,
avg(critical_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_critical_avg,
stddev(critical_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_critical_stddev,
sum(serious_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_serious_sum,
avg(serious_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_serious_avg,
stddev(serious_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_serious_stddev,
sum(low_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_low_sum,
avg(low_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_low_avg,
stddev(low_violations) FILTER (WHERE date >= '2014-10-08'::date - interval '1y') AS violations_license_num_1y_low_stddev
FROM
(
select inspection, license_num, zip_code, date,
count(*) filter (where obj ->> 'severity' = 'critical') as critical_violations,
count(*) filter (where obj ->> 'severity' = 'serious') as serious_violations,
count(*) filter (where obj ->> 'severity' = 'minor') as low_violations
from
(select inspection, license_num, zip_code, date, jsonb_array_elements(violations::jsonb) as obj from triage.test)
as t1
group by inspection, license_num, zip_code, date
) as t

WHERE date < '2014-10-08'AND date >= '2014-10-08'::date - greatest(interval '1y') GROUP BY license_num
...
#+END_EXAMPLE





*** Add number of facilities by type in a radius: 1km


#+BEGIN_SRC sql
with inspected_facilities as (
    select distinct on (license_num, location, facility_type) *
    from triage.all_facilities
),

facilities_nearby as (
   select distinct a.license_num, a.location, a.facility_type, b.facility_type as other_facility_type
   from inspected_facilities as a,
   lateral (
       select facility_type
       from semantic.entities
       where ST_DWithin(location::geography, a.location::geography, 1000)
       and license_num <> a.license_num
   ) as b
)

select
license_num, location,
facility_type, other_facility_type, count(*) as total
from facilities_nearby
group by
license_num, location, facility_type, other_facility_type;
#+END_SRC

#+RESULTS:
:RESULTS:
| license_num | location                                           | facility_type | other_facility_type                | count |
|------------+----------------------------------------------------+--------------+----------------------------------+-------|
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | bakery                           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | candy                            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | candy maker                      |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | catering                         |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | catering and wholesale           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | children's services facility     |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | daycare (2 - 6 years)            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | daycare (2 years)                |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | daycare above and under 2 years  |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | golden diner                     |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | grocery store                    |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | hospital                         |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | incubator                        |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | liqour brewery tasting           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | liquor                           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | mobile dessert vendor            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | mobile food dispenser            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | mobile food preparer             |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | mobile frozen desserts vendor    |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | mobile prepared food vendor      |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | restaurant                       |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | school                           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | school cafeteria                 |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | shared kitchen                   |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | shared kitchen user (long term)  |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | shared kitchen user (short term) |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | shelter                          |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | special event                    |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | wholesale                        |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | [NULL]                           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | bakery                           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | candy                            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | candy maker                      |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | catering                         |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | catering and wholesale           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | children's services facility     |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | daycare (2 - 6 years)            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | daycare (2 years)                |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | daycare above and under 2 years  |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | golden diner                     |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | grocery store                    |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | hospital                         |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | incubator                        |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liqour brewery tasting           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor                           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | mobile dessert vendor            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | mobile food dispenser            |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | mobile food preparer             |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | mobile frozen desserts vendor    |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | mobile prepared food vendor      |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant                       |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | school                           |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | school cafeteria                 |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | shared kitchen                   |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | shared kitchen user (long term)  |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | shared kitchen user (short term) |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | shelter                          |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | special event                    |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | wholesale                        |     1 |
|    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | [NULL]                           |     1 |
:END:

#+BEGIN_SRC python
facilities_nearby_sql = """
(
with inspected_facilities as (
    select distinct on (license_num, location, facility_type) *
    from triage.all_facilities
),

facilities_nearby as (
   select distinct a.license_num, a.location, a.facility_type, b.facility_type as other_facility_type
   from inspected_facilities as a,
   lateral (
       select facility_type
       from semantic.entities
       where ST_DWithin(location::geography, a.location::geography, 1000)
       and license_num <> a.license_num
   ) as b
)

select
license_num, location,
facility_type, other_facility_type, count(*)
from facilities_nearby
group by
license_num, location, facility_type, other_facility_type;
) as t
"""
# TODO: Create the correct aggregate Do I need to pivot the table?
facilities = Aggregate({})

st = SpacetimeAggregation([critical_violations, serious_violations, low_violations], # The Categorical object
                          from_obj=violations_sql, # FROM
                          groups=['license_num','zip_code', 'inspection'],  # GROUP BY
                          dates=["2014-10-06",
                                 "2014-10-08",
                                 "2015-01-12",
                                 "2015-10-20",
                                 "2016-10-17"], # AS OF DATES, This comes from Timechop, are used as 'WHERE date = ...'
                          intervals={"license_num": ["1y"], "zip_code": ["1y"], "inspection": ["0d"]}, # This will be used as the intervals in the past of the AS OF DATE
                          date_column="date", # Which is the name of the date column?
                          state_table='triage.all_facilities', # State table name
                          state_group='license_num', # Which is the column that identifies the entity
                          output_date_column='date',
                          schema='triage', # In which schema do you want to store the results?
                          prefix='violations'
)

st.execute(db_connection)

#+END_SRC


*** Add number of inspections by type in a radius and in an interval

QUESTION: Is this the correct SQL? (at least is fast)
IDEA: We could precalculate the distances? And from that filter by date?

#+BEGIN_SRC sql
with inspected_same_day as (
 select
   a.inspection, a.license_num, a.location, a.facility_type, a.date,
   b.inspection as other_inspection, b.facility_type as other_facility_type, b.location as other_location
   from triage.test as a,
   lateral (
      select inspection, license_num, location, facility_type, date
      from semantic.events
      where inspection <> a.inspection
      and date = a.date
   ) as b
),

inspections_nearby as (
   select
   inspection, license_num, location, facility_type,
   other_facility_type, date
   from inspected_same_day
   where
       ST_DWithin(location::geography, other_location::geography, 1000)
)

select
inspection, license_num, location, facility_type,
other_facility_type, date, count(*)
from inspections_nearby
group by
inspection, license_num, location, facility_type, other_facility_type, date
#+END_SRC

#+RESULTS:
:RESULTS:
| inspection | license_num | location                                           | facility_type | other_facility_type | count |
|------------+------------+----------------------------------------------------+--------------+-------------------+-------|
|    1084330 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1084330 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1300635 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1300635 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1300685 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1300685 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1375554 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1375554 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1480275 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1480275 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1480330 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1480330 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1480333 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1480333 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1515783 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1515783 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1583214 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1583214 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|    1966659 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|    1966659 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     347278 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     347278 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     347279 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     347279 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547248 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547248 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547249 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547249 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547250 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547250 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547251 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547251 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547252 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547252 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547253 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547253 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547254 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547254 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547255 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547255 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547256 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547256 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547257 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547257 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     547258 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     547258 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579388 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579388 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579389 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579389 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579390 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579390 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579391 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579391 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579392 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579392 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579395 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579395 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579396 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579396 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579397 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579397 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579399 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579399 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579402 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579402 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579403 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579403 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579404 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579404 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579405 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579405 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579410 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579410 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579412 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579412 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579413 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579413 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579414 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579414 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579416 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | liquor       | restaurant        |    56 |
|     579419 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579419 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579420 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579420 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579421 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579421 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579422 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579422 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579423 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579423 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579424 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579424 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579431 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579431 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579432 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579432 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     579434 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     579434 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|      58536 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|      58536 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|      58537 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|      58537 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|      58538 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|      58538 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|      58539 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|      58539 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|      58540 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|      58540 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     612586 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     612586 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
|     659526 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | liquor            |     1 |
|     659526 |    1974745 | 0101000020E6100000FCE5ED7127EB55C0C56C2285CCF04440 | restaurant   | restaurant        |    55 |
:END:

#+BEGIN_SRC python
inspections_nearby_sql = """
with inspections_nearby as (
with inspected_same_day as (
 select
   a.inspection, a.license_num, a.location, a.facility_type, a.date,
   b.inspection as other_inspection, b.facility_type as other_facility_type, b.location as other_location
   from triage.test as a,
   lateral (
      select inspection, license_num, location, facility_type, date
      from semantic.events
      where inspection <> a.inspection
      and date = a.date
   ) as c
),

inspections_nearby as (
   select
   inspection, license_num, location, facility_type,
   other_facility_type, date
   from inspected_same_day
   where
       ST_DWithin(location::geography, other_location::geography, 1000)
)

select
inspection, license_num, location, facility_type,
other_facility_type, date, count(*)
from inspections_nearby
group by
inspection, license_num, location, facility_type, other_facility_type, date
) as b
"""

# TODO: Create the correct aggregate Do I need to pivot the table?
facilities = Aggregate({})

st = SpacetimeAggregation([critical_violations, serious_violations, low_violations], # The Categorical object
                          from_obj=violations_sql, # FROM
                          groups=['license_num','zip_code', 'inspection'],  # GROUP BY
                          dates=["2014-10-06",
                                 "2014-10-08",
                                 "2015-01-12",
                                 "2015-10-20",
                                 "2016-10-17"], # AS OF DATES, This comes from Timechop, are used as 'WHERE date = ...'
                          intervals={"license_num": ["1y"], "zip_code": ["1y"], "inspection": ["0d"]}, # This will be used as the intervals in the past of the AS OF DATE
                          date_column="date", # Which is the name of the date column?
                          state_table='triage.all_facilities', # State table name
                          state_group='license_num', # Which is the column that identifies the entity
                          output_date_column='date',
                          schema='triage', # In which schema do you want to store the results?
                          prefix='violations'
)

st.execute(db_connection)

#+END_SRC

** Machine lerarning governance: The =RESULTS= schema

While =triage= is executing the experiment, it will create a new schema,
called =results=. This schema has the goal of storing the output of the
models and describing the features, parameters and hyperparameters
used in their training.

The tables contained in =results= are:

#+BEGIN_SRC sql
\dt results.
#+END_SRC

#+RESULTS:
:RESULTS:
| List of relations |                       |       |          |
|-------------------+-----------------------+-------+----------|
| Schema            | Name                  | Type  | Owner    |
| results           | evaluations           | table | food_user |
| results           | experiments           | table | food_user |
| results           | feature_importances    | table | food_user |
| results           | individual_importances | table | food_user |
| results           | list_predictions       | table | food_user |
| results           | model_groups           | table | food_user |
| results           | models                | table | food_user |
| results           | predictions           | table | food_user |
:END:

=model_groups= stores the algorithm (=model_type=), the
hyperparameters (=model_parameters=) and the features shared by a
particular set of models. =models= contains data specific to a model of
the =model_group= (you can use =model_group_id= for linking the model to a
model group) this table also includes temporal information (like
=train_end_time=) and a reference to the  train matrix
(=train_matrix_uuid=). This *UUID* is important
since that is the name of the file in which the matrix is stored.

Lastly, =results.predictions= contains all the /scores/ generated by every
model for every entity.

** ▶ TODO Audition

** ▶ TODO Post-modeling
